# Copy this file to .env.local and fill in your keys
# Google Gemini API key
GEMINI_API_KEY=

# Optionally expose in Next.js client (not recommended for production)
# NEXT_PUBLIC_GEMINI_API_KEY=


import { useEffect, useRef } from "react";
import { Client, IMessage } from "@stomp/stompjs";
import SockJS from "sockjs-client";
import { useRecoilState } from "recoil";
import { notificationsState, Notification } from "../atoms/notificationsAtom";

/**
 * WebSocket/STOMP notifications bridge.
 * Connects to Spring Boot SockJS endpoint and subscribes to user notifications queue.
 * Requires env: NEXT_PUBLIC_WS_URL (e.g., http://localhost:8080/ws)
 */
export function useStompNotifications(enabled: boolean = true) {
  const [notifState, setNotifState] = useRecoilState(notificationsState);
  const clientRef = useRef<Client | null>(null);

  useEffect(() => {
    if (!enabled) return;
    if (typeof window === 'undefined') return;
    if ((window as any).__wsActive && clientRef.current) {
      try { console.log('[WS] already active, skipping re-init'); } catch {}
      return;
    }
  const wsUrl = process.env.NEXT_PUBLIC_WS_URL || 'https://rehearten-production.up.railway.app/ws';
  const transportPref = (process.env.NEXT_PUBLIC_WS_TRANSPORT || '').toLowerCase(); // 'sockjs' | 'native'
    // Resolve token and role client-side
    const getToken = () => {
      try {
        const cookie = document.cookie || '';
        const m = cookie.match(/(?:^|; )token=([^;]+)/);
        if (m && m[1]) {
          let v = decodeURIComponent(m[1]);
          try { const p = JSON.parse(v); if (p && p.token) return String(p.token); } catch {}
          return v;
        }
      } catch {}
      try { const ls = window.localStorage.getItem('authToken'); if (ls) { try { const p = JSON.parse(ls); if (p && p.token) return String(p.token); } catch {} return ls; } } catch {}
      return undefined;
    };
    const token = getToken();
    // Resolve role: prefer persisted, else try to decode from JWT
    const persistedRole = (typeof window !== 'undefined' ? String(window.localStorage.getItem('role') || '') : '').toLowerCase();
    const decodeRoleFromJwt = (t?: string): string | '' => {
      if (!t) return '';
      try {
        const part = t.split('.')[1];
        const json = atob(part.replace(/-/g, '+').replace(/_/g, '/'));
        const payload = JSON.parse(json);
        const r = payload?.role || (Array.isArray(payload?.roles) ? payload.roles[0] : undefined) || (payload?.isAdmin ? 'admin' : undefined);
        return r ? String(r).toLowerCase() : '';
      } catch { return ''; }
    };
    const role = persistedRole || decodeRoleFromJwt(token) || '';
    try {
      console.log('[WS] init', { wsUrl, hasToken: !!token, tokenLen: token ? token.length : 0, role });
      console.log('[WS] Đang chuẩn bị kết nối tới WebSocket...', wsUrl);
    } catch {}

  let wsUrlWithToken = wsUrl;
  if (token) {
    const sep = wsUrl.includes('?') ? '&' : '?';
    // Send both param names for compatibility with various backends, plus role if available
    const roleParam = role ? `&role=${encodeURIComponent(role)}` : '';
    wsUrlWithToken = `${wsUrl}${sep}token=${encodeURIComponent(token)}&access_token=${encodeURIComponent(token)}${roleParam}`;
  }
  try { console.log('[WS] connecting', { wsUrlWithToken, transportPref: transportPref || 'sockjs' }); } catch {}
  // Prefer native WebSocket when requested, otherwise SockJS with sensible fallbacks
  const socketLike: any = (() => {
    if (transportPref === 'native') {
      try {
        const nativeUrl = wsUrlWithToken.replace(/^http:/i, 'ws:').replace(/^https:/i, 'wss:');
        try { console.log('[WS] using native WebSocket', { nativeUrl }); } catch {}
        return new (window as any).WebSocket(nativeUrl);
      } catch (e) {
        try { console.warn('[WS] native WebSocket failed, falling back to SockJS', e); } catch {}
      }
    }
    const options: any = {
      transports: ['websocket', 'xhr-streaming', 'xhr-polling'],
      transportOptions: {
        'xhr-streaming': { withCredentials: true },
        'xhr-polling': { withCredentials: true },
      },
      timeout: 10000,
    };
    return new SockJS(wsUrlWithToken, undefined as any, options);
  })();
    const client = new Client({
      webSocketFactory: () => socketLike as any,
      debug: (str: string) => { if (process.env.NODE_ENV !== 'production') console.log('[STOMP]', str); },
      reconnectDelay: 3000,
  connectHeaders: token ? ({ Authorization: `Bearer ${token}`, ...(role ? { 'X-User-Role': role } : {}) } as any) : (role ? ({ 'X-User-Role': role } as any) : undefined),
    });
    clientRef.current = client;

    client.onConnect = () => {
      try {
        console.log('[WS] connected');
        console.log('ĐÃ KẾT NỐI TỚI WEBSOCKET ✅', { at: new Date().toISOString(), url: wsUrlWithToken });
      } catch {}
      // For admin accounts, write a local notification about successful WS connection (once per session)
      try {
        if (role === 'admin' && typeof window !== 'undefined' && !(window as any).__wsAdminConnectNotified) {
          const now = new Date();
          const n: Notification = {
            id: `ws_connected_${now.getTime()}`,
            type: 'post' as any,
            message: 'ĐÃ KẾT NỐI TỚI WEBSOCKET ✅',
            userId: '',
            targetUserId: '',
            pending: false,
            timestamp: { toDate: () => now } as any,
            read: false,
          } as Notification;
          setNotifState(prev => {
            const notifications = [n, ...prev.notifications];
            const unreadCount = notifications.filter(x => !x.read).length;
            return { ...prev, notifications, unreadCount };
          });
          (window as any).__wsAdminConnectNotified = true;
        }
      } catch {}
  // Subscribe to user notifications queue
      client.subscribe('/user/queue/notifications', (message: IMessage) => {
        try { console.log('[WS] /user/queue/notifications message', { body: message?.body?.slice?.(0, 200) }); } catch {}
        const now = new Date();
        let parsed: any = undefined;
        try { parsed = message?.body ? JSON.parse(message.body) : undefined; } catch {}
        // Build a clear message for admins: "<username> đã đăng một bài mới ..."
        const typeRaw = (parsed?.type || parsed?.event || '').toString().toLowerCase();
        const isPostEvent = ['post', 'post_created', 'new_post', 'create_post'].includes(typeRaw);
        const actor = parsed?.userName || parsed?.username || parsed?.authorName || parsed?.createdByName || parsed?.createdBy || parsed?.displayName || parsed?.email || parsed?.userId;
        const postTitle = parsed?.postTitle || parsed?.title;
        const community = parsed?.communityName || parsed?.community;
        const adminMessage = `${actor || 'Người dùng'} đã đăng một bài mới${postTitle ? `: "${postTitle}"` : ''}''}`;
        const body = (role === 'admin' && isPostEvent) ? adminMessage : (parsed?.message || message?.body || '');
        const n: Notification = {
          id: `${now.getTime()}_${Math.random().toString(36).slice(2)}`,
          type: parsed?.type || 'post',
          message: body,
          userId: parsed?.userId || '',
          targetUserId: parsed?.targetUserId || '',
          postId: parsed?.postId,
          postTitle: parsed?.postTitle,
          communityName: parsed?.communityName,
          pending: parsed?.pending ?? true,
          timestamp: { toDate: () => now } as any,
          read: false,
        } as Notification;
        try { console.log('[WS] mapped notification', { type: n.type, postId: n.postId, pending: n.pending }); } catch {}
        setNotifState(prev => {
          const notifications = [n, ...prev.notifications];
          const unreadCount = notifications.filter(x => !x.read).length;
          return { ...prev, notifications, unreadCount };
        });
      });
      // Fallback/broadcast topic for admins
      if (role === 'admin') {
        try { console.log('[WS] subscribing /topic/admin-notifications'); } catch {}
        client.subscribe('/topic/admin-notifications', (message: IMessage) => {
          try { console.log('[WS] /topic/admin-notifications message', { body: message?.body?.slice?.(0, 200) }); } catch {}
          const now = new Date();
          let parsed: any = undefined;
          try { parsed = message?.body ? JSON.parse(message.body) : undefined; } catch {}
          // Build a clear message for admins: "<username> đã đăng một bài mới ..."
          const typeRaw = (parsed?.type || parsed?.event || '').toString().toLowerCase();
          const isPostEvent = ['post', 'post_created', 'new_post', 'create_post'].includes(typeRaw);
          const actor = parsed?.userName || parsed?.username || parsed?.authorName || parsed?.createdByName || parsed?.createdBy || parsed?.displayName || parsed?.email || parsed?.userId;
          const postTitle = parsed?.postTitle || parsed?.title;
          const community = parsed?.communityName || parsed?.community;
          const adminMessage = `${actor || 'Người dùng'} đã đăng một bài mới${postTitle ? `: "${postTitle}"` : ''}''}`;
          const body = isPostEvent ? adminMessage : (parsed?.message || message?.body || '');
          const n: Notification = {
            id: `${now.getTime()}_${Math.random().toString(36).slice(2)}`,
            type: parsed?.type || 'post',
            message: body,
            userId: parsed?.userId || '',
            targetUserId: parsed?.targetUserId || '',
            postId: parsed?.postId,
            postTitle: parsed?.postTitle,
            communityName: parsed?.communityName,
            pending: parsed?.pending ?? true,
            timestamp: { toDate: () => now } as any,
            read: false,
          } as Notification;
          try { console.log('[WS] mapped admin notification', { type: n.type, postId: n.postId, pending: n.pending }); } catch {}
          setNotifState(prev => {
            const notifications = [n, ...prev.notifications];
            const unreadCount = notifications.filter(x => !x.read).length;
            return { ...prev, notifications, unreadCount };
          });
        });
      }
    };

  client.onStompError = (frame: any) => {
      try { console.error('[WS] stomp error', { message: frame?.headers?.message, body: frame?.body }); } catch {}
    };
    (client as any).onWebSocketError = (evt: any) => {
      try { console.error('[WS] socket error', evt); } catch {}
    };
    (client as any).onWebSocketClose = (evt: any) => {
      try { console.warn('[WS] socket closed', { code: evt?.code, reason: evt?.reason }); } catch {}
    };

    client.activate();
    (window as any).__wsActive = true;
    return () => {
      try { console.log('[WS] deactivate'); } catch {}
      client.deactivate();
      clientRef.current = null;
      (window as any).__wsActive = false;
    };
  }, [enabled]);
}
export default useStompNotifications;